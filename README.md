mini_ecdsa
===============

Arithmetic on elliptic curves and introduction to ECDSA in Python.

*Disclaimer*: This module is a tool for learning about elliptic curves and elliptic curve cryptography. It provides a fully functional implementation of ECDSA, but don't use it as anything other than a sandbox. Even if the math is correct there are many [important implementation details](http://safecurves.cr.yp.to/index.html) required for private key security not considered here.

Let's start by defining a Weierstrass curve over a field of prime characteristic, or over the rationals. `Curve(a,b,c,p)` will define an elliptic curve with Weierstrass form y^2 = x^3 + ax^2 + bx + c over F_p. `Curve(a,b,c,0)` will define a curve with the same equation over the rationals.

```
>>> C = Curve(2, 0, 1, 7)
y^2 = x^3 + 2x^2 + 1 over F_7
```

To see a list of all points on the curve, or all finite order rational points for curves defined over Q, use `C.show_points()`. This will produce a pretty printed set of points. To return a list of point objects, use `C.get_points()`.

```
>>> C.show_points()
['Inf', '(0,1)', '(0,6)', '(1,2)', '(1,5)', '(3,2)', '(3,5)', '(5,1)', '(5,6)', '(6,3)', '(6,4)']
```

For curves defined over the rational numbers, calling `C.torsion_group()` will classify the group of finite order rational points of the curve, also known as torsion points, as well as displaying these points. *Warning:* This is a work in progress. Attempting to find the torsion points on a curve will fill your machine's memory up and cause it to hang unless the curve has a very small discriminant, so be careful. Let's say we want to see the group of torsion points on the curve y^2 = x^3 + x + 2.

```
>>> C = Curve(0, 1, 2, 0)
y^2 = x^3 + x + 2 over Q
>>> C.torsion_group()
Z/4Z
['Inf', '(-1,0)', '(1,2)', '(1,-2)']
```

In this case, the finite order rational points on the curve form a cyclic group of order four. You can also mess around with arithmetic on the curve by adding points, multiplying them by integers (remember multiplication in this context means repeated addition), and so on.

```
>>> C = Curve(0, 1, 2, 0)
y^2 = x^3 + x + 2 over Q
>>> P = Point(-1,0)
>>> Q = Point(1,2)
>>> C.contains(P)
True
>>> C.contains(Q)
True
>>> print C.add(P,Q)
(1,-2)
>>> print C.mult(Q,4)
Inf
```

ECDSA is a digital signature scheme which uses elliptic curves. One of its best known uses is in Bitcoin, where spending money amounts to generating a valid ECDSA signature. Any user able to forge ECDSA signatures would become an instant billionaire.

To use ECDSA, we need to publicly agree on a curve over a prime characteristic field (any finite field can be used, but this module only works with prime characteristic fields) along with a distinguished point that generates a subgroup of order n, where n is required to be prime. Why prime order? As part of signing process, we'll need to find a multiplicative inverse mod n, and the primality requirement guarantees that will work.

*Toy Example*: Consider P = (1341,854) on the curve y^2 = x^3 + x + 1 over the field with 2833 elements.

```
>>> C = Curve(0, 1, 1, 2833)
y^2 = x^3 + x + 1 over F_2833
>>> P = Point(1341,854)
>>> C.contains(P)
True
>>> C.order(P)
131
```

Thus, P is indeed on the curve, and P generates a subgroup of order 131, which is prime, so we can use the curve C with the distinguished point P to sign and verify messages with ECDSA. The curve C, the point P, and the order of P are all public information.

To sign a message, start by creating a private-public keypair by calling `generate_keypair`. This keypair will consist of a randomly generated positive integer d smaller than the order of P, and a point Q = dP. Computing Q given d and P can be done very quickly, but at the moment, no one knows any effective and generally applicable method of computing d given P and Q. This is the [one-way function](https://en.wikipedia.org/wiki/One-way_function) that provides the theoretical security in all elliptic curve cryptography schemes.

```
>>> key = generate_keypair(C, P, 131)
Priv key: d = 71
Publ key: Q = (1449,1186)
```

Digital signatures generated by ECDSA consist of a public key Q as well as two positive integers, r and s, which are smaller than the order of P. These values are computed using the private key d and a hash of the message. In this implementation I used sha256 as the hash function. The signature is returned as a tuple when calling `sign`, and also printed nicely.

```
>>> msg = 'this is an important message'
>>> sig = sign(msg, C, P, 131, key)
ECDSA sig: ((1449,1186), 105, 8)
```

Another randomly selected positive integer smaller than the order of P is chosen as part of the signature generation process. This value, k, is a [nonce](https://en.wikipedia.org/wiki/Cryptographic_nonce). It is crucially important to generate a new random k each time a message is signed. As a consequence, if a fixed message is signed multiple times, a different signature will be produced each time. Well-known attacks on ECDSA have exploited implementations which have problems generating k.

The recipient can verify the authenticity of the message by calling `verify`, which takes a message and signature, as well as the public curve parameters used to generate the signature, and checks that the signature is valid. Any modification of the message will, with very high probability, result in verify returning `False`.

```
>>> verify('this is an important message', C, P, 131, sig)
True
>>> verify('thiz is an important mossage', C, P, 131, sig)
False
```

*Big Example*: The curve used to verify Bitcoin transactions is known as secp256k1. In practice, when someone says 'curve' they usually mean an elliptic curve with a distinguished point of a given order. It's not hard to find out the details for secp256k1 with a few minutes of internetting and converting things to decimal.

```
>>> C = Curve(0, 0, 7, 2**256-2**32-2**9-2**8-2**7-2**6-2**4-1)
y^2 = x^3 + 7 over F_115792089237316195423570985008687907853269984665640564039457584007908834671663
>>> P = Point(55066263022277343669578718895168534326250603453777594175500187360389116729240,
... 32670510020758816978083085130507043184471273380659243275938904335757337482424)
>>> n = 115792089237316195423570985008687907852837564279074904382605163141518161494337
```

There are few noteworthy things about the order of P. It's specified, not calculated, which seems strange until you realize that, at least naively, to find the order of a point we need to calculate iP for increasing i until we get the point at infinity. If that was actually feasible, we could crack public keys and recover d from Q in the same way, by calculating iP for increasing i until the result is Q. Calling `C.order(P)` will indeed calculate the order of P in this naive way, so don't do it unless you're prepared to wait a long time, and by long I mean universe ending long.

Also, note how close the order of P is to the size of the field the curve is defined over. If you've studied elliptic curves before and know about the [Hasse bound](https://en.wikipedia.org/wiki/Hasse's_theorem_on_elliptic_curves) along with a little bit of group theory, you should be able to convince yourself that the subgroup generated by P is actually the entire set of points on the curve. This is good, as it makes our keyspace, the set of possible values for d, as large as possible.

To sign and authenticate messages, we just do the same thing we did in the toy example.

```
>>> key = generate_keypair(C, P, n)
Priv key: 50815196737043990229212712040447958865064188767262580693117504952509239687366
Publ key: (60178516215593300273458789571475750050105656844208932820175446762050535381256,92933466624192676140900093650081093228918214155456856436706041935976250501492)
>>> msg = 'this is an important message'
>>> sig = sign(m, C, P, n, key)
ECDSA sig: ((60178516215593300273458789571475750050105656844208932820175446762050535381256,92933466624192676140900093650081093228918214155456856436706041935976250501492), 67756844576696401107541526159652184771668032529513958275679795576766605561987, 18515072816757752760109761447693938223957409424050002694174985246358775622034)
>>> verify('this is an important message', C, P, n, sig)
True
>>> verify('this is a faked important message', C, P, n, sig)
False
```
