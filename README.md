mini_ecdsa
===============

Basics of elliptic curves and ECDSA in Python.

*Disclaimer*: There is a lot of brute forcing going on here. This is a *low performance* package intended to be helpful to those interested in learning about elliptic curves and ECDSA.

Start by defining a Weierstrass curve over a field of prime characteristic, or over the rationals. For example, let's say you want to know about the curve y^2 = x^3 + 2x^2 + 1 over F_7.

```
>>> C = Curve(2,0,1,7)
y^2 = x^3 + 2x^2 + 1 over F_7
```

To see a list of all points on the curve, or all finite order rational points for curves defined over Q, use `C.show_points()`. This will produce a pretty printed set of points. To return a list of point objects, use `C.get_points()`.

```
>>> C.show_points()
['Inf', '(0,1)', '(0,6)', '(1,2)', '(1,5)', '(3,2)', '(3,5)', '(5,1)', '(5,6)', '(6,3)', '(6,4)']
```

For curves defined over the rational numbers, calling `C.torsion_group()` will classify the torsion group of the curve, as well as displaying all finite order rational points. *Warning:* Attempting to find the torsion points on a curve will fill your machine's memory up and cause it to hang unless the curve has a very small discriminant, so be careful. Let's say we want to see the group of torsion points on the curve y^2 = x^3 + x + 2.

```
>>> C = Curve(0,1,2,0)
y^2 = x^3 + x + 2 over Q
>>> C.torsion_group()
Z/4Z
['Inf', '(-1,0)', '(1,2)', '(1,-2)']
```

You'll see that it's a cyclic group of order four, as well as the coordinates of all the torsion points. You can also mess around inside the torsion group by adding points, multiply them by scalars, and so on.

```
>>> C = Curve(0,1,2,0)
y^2 = x^3 + x + 2 over Q
>>> P = Point(-1,0)
>>> Q = Point(1,2)
>>> C.contains(P)
True
>>> C.contains(Q)
True
>>> print C.add(P,Q)
(1,-2)
>>> print C.mult(Q,4)
Inf
```

ECDSA is a digital signature scheme which uses elliptic curves. One of its best known uses is in Bitcoin, where spending money amounts to generating a valid ECDSA signature. Any user able to forge ECDSA signatures would become an instant billionaire.

To use ECDSA to create digital signatures, we first need to publicly agree on a curve over a prime characteristic field (any finite field can be used, but this module only works with prime characteristic fields) with a distinguished point that generates a prime order subgroup. Let's use P = (1341,854) on the curve y^2 = x^3 + x + 1 over the field with 2833 elements.

```
>>> C = Curve(0,1,1,2833)
y^2 = x^3 + x + 1 over F_2833
>>> P = Point(1341,854)
>>> C.contains(P)
True
>>> C.order(P)
131
```

Thus, P is indeed on the curve, and generates a subgroup of order 131, which is prime, so we can use the curve C with the distinguished point P to sign and verify messages with ECDSA. The curve C and the point P are both public information. Digital signatures generated by ECDSA will consist of a point Q on the curve, which is a multiple of P, as well as two values r and s which are positive integers smaller than the order of P. This signature is returned as a tuple when calling `sign`, and also printed nicely.

```
>>> m = 'this is a message'
>>> S = sign(m,C,P)
Sig: ((2387,711), 40, 38)
```

Two points in the subgroup generated by P (i.e. positive integers smaller than the order of P) are selected at random as part of the signature generation process. In this implementation these are the variables `d` and `k` used in the `sign` routine. The quantity `d` is the private key corresponding to the public key `Q` which is given in the signature. Such a keypair could be used to sign multiple messages, although in this implementation each private key is used only once. However, `k` is a [nonce](https://en.wikipedia.org/wiki/Cryptographic_nonce), and it is crucially important to generate a new random `k` each time a message is signed. As a consequence, if a fixed message is signed multiple times, a different signature will be produced each time. Well-known attacks on ECDSA have exploited implementations which have problems generating `k`.

The recipient can verify the authenticity of the message by calling `verify`, which takes a message and signature, as well as the curve and distinguished point used to generate the signature, and checks that the signature is valid. Any modification of the message will, with very high probability, result in verify returning `False`.

```
>>> verify('this is a message',C,P,S)
True
>>> verify('thiz is a mossage',C,P,S)
False
```
